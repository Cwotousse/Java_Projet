package be.mousty.accessToDao;
/**
	Classe métier relatif liée à la classe DisponibiliteMoniteur et DisponibiliteMoniteurDAO.
	@author Adrien MOUSTY
	@version Finale 1.3.3
	@category Métier
 */
import java.sql.Date;
import java.util.ArrayList;

import be.mousty.dao.AbstractDAOFactory;
import be.mousty.dao.DAO;
import be.mousty.pojo.Accreditation;
import be.mousty.pojo.DisponibiliteMoniteur;
import be.mousty.pojo.Semaine;

public class DisponibiliteMoniteurATD {
	// VARIABLES
	private boolean disponible;

	// CONSTRUCTEURS
	public DisponibiliteMoniteurATD(){}
	public DisponibiliteMoniteurATD(boolean disponible){ this.disponible 	= disponible; }
	public DisponibiliteMoniteurATD(DisponibiliteMoniteur DM){ this.disponible 	= DM.getDisponible(); }


	// APPEL AUX METHODES DAO DANS LES CLASSES METIER
	AbstractDAOFactory adf = AbstractDAOFactory.getFactory(AbstractDAOFactory.DAO_FACTORY);
	DAO<DisponibiliteMoniteur> DisponibiliteMoniteurDAO = adf.getDisponibiliteMoniteurDAO();
	public int						create	(DisponibiliteMoniteur d) 		{ return DisponibiliteMoniteurDAO.create(d); 	}
	public boolean 					delete	()	 							{ return DisponibiliteMoniteurDAO.delete(null); }
	public DisponibiliteMoniteur 	getId	(DisponibiliteMoniteur d) 		{ return DisponibiliteMoniteurDAO.getId(d); 	}
	public boolean 					update	(DisponibiliteMoniteur d) 		{ return DisponibiliteMoniteurDAO.update(d); 	}
	public DisponibiliteMoniteur 	find	(int id) 						{ return DisponibiliteMoniteurDAO.find(id); 	} 
	public ArrayList<DisponibiliteMoniteur> getListCP 			() 					{ return DisponibiliteMoniteurDAO.getList(); 	} 
	public ArrayList<DisponibiliteMoniteur> getMyListSelonID	(int idMoniteur)	{ return DisponibiliteMoniteurDAO.getMyListSelonID(idMoniteur, -1, -1, ""); 	}
	public void creerTouteDisponibilites						()					{ DisponibiliteMoniteurDAO.creerTouteDisponibilites();		}
	public void creerTouteDisponibilitesSelonMoniteur			(int numMoniteur) 	{ DisponibiliteMoniteurDAO.creerTouteDisponibilitesSelonMoniteur(numMoniteur); }
	public boolean getListSelonCriteres(DisponibiliteMoniteur obj) {
		ArrayList<DisponibiliteMoniteur> listBoolean = DisponibiliteMoniteurDAO.getListSelonCriteres(obj);
		boolean valRetour = listBoolean == null ? true : false; 
		return valRetour; // Si true, ça a fonctionné.
	}


	// FONCTION SURCHARGEE
	@Override public String toString() { return  "Le moniteur est disponible : " + disponible + "."; }

	// METHODES
	public ArrayList<DisponibiliteMoniteurATD> getListDispo(int numMoniteur){
		ArrayList<DisponibiliteMoniteur> listDispo  = getMyListSelonID(numMoniteur);
		ArrayList<DisponibiliteMoniteurATD> listDispoATD = new ArrayList<DisponibiliteMoniteurATD>();
		for(int i = 0; i < listDispo.size(); i++){
			DisponibiliteMoniteurATD DMATD = new DisponibiliteMoniteurATD();
			DMATD.setDisponible(listDispo.get(i).getDisponible());
			listDispoATD.add(DMATD);
		}
		return listDispoATD;
	}

	public boolean updateDispo(Date dateDebut, int numMoniteur){
		SemaineATD SATD = new SemaineATD();
		Semaine S = new Semaine();
		S.setDateDebut(dateDebut);
		boolean EtatDispo = true;
		long numSemaine;
		S = SATD.getId(S); // numéro de semaine
		DisponibiliteMoniteur DM = new DisponibiliteMoniteur();
		DM.setNumSemaine(S.getNumSemaine());
		numSemaine = S.getNumSemaine();
		DM.setNumMoniteur(numMoniteur);
		if(getListSelonCriteres(DM)){
			// Après l'update, on récupère la dispo pour la semaine
			ArrayList<DisponibiliteMoniteur> fullDispo  = getMyListSelonID(numMoniteur);
			for(DisponibiliteMoniteur dm : fullDispo){
				// On recherche le numéro de semaine
				if (dm.getNumSemaine() == DM.getNumSemaine()){
					EtatDispo = dm.getDisponible();
				}
			}

			// Si il est sur false on rechercher un nouveau moniteur pour le suppléer ses réservation à la date indiquée
			if (!EtatDispo){
				// Il faut récupérer ses réservations, s'il en a.
				ReservationATD RATD = new ReservationATD();
				ArrayList<ReservationATD> listReservationMoniteurSelonNumSemaine = new ArrayList<ReservationATD>();
				ArrayList<ReservationATD> listFullReservation = RATD.getMyListATD(numMoniteur);
				for(ReservationATD ratd : listFullReservation){
					if (ratd.getSemaine().getDateDebut().equals(dateDebut)){
						listReservationMoniteurSelonNumSemaine.add(ratd);
					}
				}
				// Il y a des reservations dispo
				if (!listReservationMoniteurSelonNumSemaine.isEmpty()){
					System.out.println("Des réservations ont étés trouvées ("+ listReservationMoniteurSelonNumSemaine.size() +"). Nous procédons à l'attribution d'un nouveau moniteur pour vos cours");

					MoniteurATD ancienMoniteur = new MoniteurATD();
					ancienMoniteur = ancienMoniteur.findM(numMoniteur);


					ArrayList <MoniteurATD> listeMoniteurAyantLesMêmesAccreditations = new ArrayList <MoniteurATD>();
					int typeCours = 1; // 1 -> collectif, 2 -> particulier
					// Recherche d'un nouveau moniteur pour chaque cours
					for(ReservationATD ratd : listReservationMoniteurSelonNumSemaine){
						// Pour la réservation il faut trouver le type de cours donné, s'il correspond avec une accred alors on le prend (on exclu aussi le moniteur qui se désiste)
						ArrayList <MoniteurATD> listeMoniteursDispo = new ArrayList <MoniteurATD>();
						ArrayList <MoniteurATD> listeMoniteursDispoAvecAccred = new ArrayList <MoniteurATD>();
						if (ratd.getMoniteur().getNumMoniteur() != ancienMoniteur.getNumId()){
							if (ratd.getCours().getPrix() < 90) { 
								// Cours particulier
								listeMoniteursDispo = ancienMoniteur.getListDispoATD(2, dateDebut.getTime(), ratd.getCours().getPeriodeCours());
							}
							else {
								// coursCollectif
								listeMoniteursDispo = ancienMoniteur.getListDispoATD(1, numSemaine, ratd.getCours().getPeriodeCours());
							}
						}

						// Il y au moins un moniteur disponible, on verifie ses accreditations
						if (!listeMoniteursDispo.isEmpty()){
							
							
							for(MoniteurATD mon : listeMoniteursDispo){
								ArrayList<AccreditationATD> listaccredMoniteur = mon.getAccrediList();
								for(AccreditationATD A : listaccredMoniteur){
									// On compare les accréditations avec les moniteurs disponibles
									if (A.getNom().equals(ratd.getCours().getNomSport())){
										System.out.println("Un moniteur a été trouvé, nous vérifions le nombre maximum d'élèves.");
									}
								}
								
							}

						}
						// On supprime le cours
						else {
							System.out.println("Aucun moniteur n'a été trouvé, un le cours de " + ratd.getCours().getNomSport() + " a été supprimé.");

						}
					}

					// S'il n'y a pas de moniteurs, dispo, on supprime les réservations
					//ReservationATD RATD = new ReservationATD();
				}

			}
		}

		return EtatDispo;
	}

	// PROPRIETE
	public boolean 	getDisponible	() 						{ return disponible; 			}
	public void 	setDisponible	(boolean disponible)	{ this.disponible = disponible; }
}

